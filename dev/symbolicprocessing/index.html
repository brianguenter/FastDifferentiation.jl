<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic processing · FastDifferentiation.jl</title><meta name="title" content="Symbolic processing · FastDifferentiation.jl"/><meta property="og:title" content="Symbolic processing · FastDifferentiation.jl"/><meta property="twitter:title" content="Symbolic processing · FastDifferentiation.jl"/><meta name="description" content="Documentation for FastDifferentiation.jl."/><meta property="og:description" content="Documentation for FastDifferentiation.jl."/><meta property="twitter:description" content="Documentation for FastDifferentiation.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FastDifferentiation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../limitations/">Limitations</a></li><li><a class="tocitem" href="../howitworks/">How it works</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../makefunction/">How to use make_function</a></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li class="is-active"><a class="tocitem" href>Symbolic processing</a></li><li><a class="tocitem" href="../futurework/">Future work</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Symbolic processing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic processing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/brianguenter/FastDifferentiation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/brianguenter/FastDifferentiation.jl/blob/main/docs/src/symbolicprocessing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Symbolic-Processing"><a class="docs-heading-anchor" href="#Symbolic-Processing">Symbolic Processing</a><a id="Symbolic-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Processing" title="Permalink"></a></h1><p>Because <strong>FD</strong> can generate true symbolic derivatives it can easily be used in conjunction with Symbolics.jl using the package <a href="https://github.com/brianguenter/FDConversion.jl">FDConversion.jl</a> (still under development).</p><p>A rule of thumb is that if your function is small (a few hundred operations or less) or tree like (where each node in the expression graph has one parent on average) then Symbolics.jl may outperform or equal <strong>FD</strong>. For more complex functions with many common subexpressions <strong>FD</strong> may substantially outperform Symbolics.jl.</p><p>Take these benchmarks with a large grain of salt since there are so few of them. Whether your function will have this kind of performance improvement relative to Symbolics.jl is hard to predict until the benchmark set gets much bigger.</p><p>These benchmarks should give you a sense of what performance you might achieve for symbolic processing. There are three types of benchmarks: <strong>Symbolic</strong>, <strong>MakeFunction</strong>, and <strong>Exe</strong>.</p><ul><li><p>The <strong>Symbolic</strong> benchmark is the time required to compute just the symbolic form of the derivative. The Symbolic benchmark can be run with simplification turned on or off for Symbolics.jl. If simplification is on then computation time can be extremely long but the resulting expression might be simpler and faster to execute.</p></li><li><p>The <strong>MakeFunction</strong> benchmark is the time to generate a Julia Expr from an already computed symbolic derivative and to then compile it.</p></li><li><p>The <strong>Exe</strong> benchmark measures just the time required to execute the compiled function using an in-place matrix.</p></li></ul><p>All benchmarks show the ratio of time taken by Symbolics.jl to FastDifferentiation.jl. Numbers greater than 1 mean FastDifferentiation is faster.</p><p>All benchmarks were run on an AMD Ryzen 9 7950X 16-Core Processor with 32GB RAM running Windows 11 OS, Julia version 1.9.0.</p><h3 id="Chebyshev-polynomial"><a class="docs-heading-anchor" href="#Chebyshev-polynomial">Chebyshev polynomial</a><a id="Chebyshev-polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#Chebyshev-polynomial" title="Permalink"></a></h3><p>The first example is a recursive function for  the Chebyshev polynomial of order n:</p><pre><code class="language-julia hljs">@memoize function Chebyshev(n, x)
    if n == 0
        return 1
    elseif n == 1
        return x
    else
        return 2 * (x) * Chebyshev(n - 1, x) - Chebyshev(n - 2, x)
    end
end</code></pre><p>The function is memoized so the recursion executes efficiently. </p><p>The recursive function returns an nth order polynomial in the variable x. The derivative of this polynomial would be order n-1 so a perfect symbolic simplification would result in a function with 2*(n-2) operations. For small values of n Symbolics.jl simplification does fairly well but larger values result in very inefficient expressions.</p><p>Because <strong>FD</strong> doesn&#39;t do sophisticated symbolic simplification it generates a derivative with approximately 2.4x the number of operations in the original recursive expression regardless of n. This is a case where a good hand generated derivative would be more efficient than <strong>FD</strong>.</p><p>The Chebyshev expression graph does not have many nodes even at the largest size tested (graph size increases linearly with Chebyshev order).</p><p>The first set of three benchmarks show results with simplification turned off in Symbolics.jl, followed by a set of three with simplification turned on. Performance is somewhat better in the latter case but still slower than the FD executable. Note that the y axis is logarithmic.</p><h4 id="Chebyshev-benchmarks-with-simplification-off"><a class="docs-heading-anchor" href="#Chebyshev-benchmarks-with-simplification-off">Chebyshev benchmarks with simplification off</a><a id="Chebyshev-benchmarks-with-simplification-off-1"></a><a class="docs-heading-anchor-permalink" href="#Chebyshev-benchmarks-with-simplification-off" title="Permalink"></a></h4><p><img src="../Illustrations/figure_chebyshev_Symbolic_simplify_false.svg" alt="Symbolic processing, simplify=false"/>  <img src="../Illustrations/figure_chebyshev_MakeFunction_simplify_false.svg" alt="MakeFunction, simplify=false"/>  <img src="../Illustrations/figure_chebyshev_Exe_simplify_false.svg" alt="Exe, simplify=false"/></p><h4 id="Chebyshev-benchmarks-with-simplification-on"><a class="docs-heading-anchor" href="#Chebyshev-benchmarks-with-simplification-on">Chebyshev benchmarks with simplification on</a><a id="Chebyshev-benchmarks-with-simplification-on-1"></a><a class="docs-heading-anchor-permalink" href="#Chebyshev-benchmarks-with-simplification-on" title="Permalink"></a></h4><p><img src="../Illustrations/figure_chebyshev_Exe_simplify_true.svg" alt="MakeFunction, simplify=false"/></p><p>With simplification on performance of the executable derivative function for Symbolics.jl is slightly better than with simplification off. But simplification processing time is longer.</p><h3 id="Spherical-Harmonics"><a class="docs-heading-anchor" href="#Spherical-Harmonics">Spherical Harmonics</a><a id="Spherical-Harmonics-1"></a><a class="docs-heading-anchor-permalink" href="#Spherical-Harmonics" title="Permalink"></a></h3><p>The second example is the spherical harmonics function. This is the expression graph for the spherical harmonic function of order 8: <img src="../Illustrations/sphericalharmonics_8.svg" alt="MakeFunction, simplify=false"/></p><pre><code class="language-julia hljs">@memoize function P(l, m, z)
    if l == 0 &amp;&amp; m == 0
        return 1.0
    elseif l == m
        return (1 - 2m) * P(m - 1, m - 1, z)
    elseif l == m + 1
        return (2m + 1) * z * P(m, m, z)
    else
        return ((2l - 1) / (l - m) * z * P(l - 1, m, z) - (l + m - 1) / (l - m) * P(l - 2, m, z))
    end
end
export P

@memoize function S(m, x, y)
    if m == 0
        return 0
    else
        return x * C(m - 1, x, y) - y * S(m - 1, x, y)
    end
end
export S

@memoize function C(m, x, y)
    if m == 0
        return 1
    else
        return x * S(m - 1, x, y) + y * C(m - 1, x, y)
    end
end
export C

function factorial_approximation(x)
    local n1 = x
    sqrt(2 * π * n1) * (n1 / ℯ * sqrt(n1 * sinh(1 / n1) + 1 / (810 * n1^6)))^n1
end
export factorial_approximation

function compare_factorial_approximation()
    for n in 1:30
        println(&quot;n $n relative error $((factorial(big(n))-factorial_approximation(n))/factorial(big(n)))&quot;)
    end
end
export compare_factorial_approximation

@memoize function N(l, m)
    @assert m &gt;= 0
    if m == 0
        return sqrt((2l + 1 / (4π)))
    else
        # return sqrt((2l+1)/2π * factorial(big(l-m))/factorial(big(l+m)))
        #use factorial_approximation instead of factorial because the latter does not use Stirlings approximation for large n. Get error for n &gt; 2 unless using BigInt but if use BigInt get lots of rational numbers in symbolic result.
        return sqrt((2l + 1) / 2π * factorial_approximation(l - m) / factorial_approximation(l + m))
    end
end
export N

&quot;&quot;&quot;l is the order of the spherical harmonic&quot;&quot;&quot;
@memoize function Y(l, m, x, y, z)
    @assert l &gt;= 0
    @assert abs(m) &lt;= l
    if m &lt; 0
        return N(l, abs(m)) * P(l, abs(m), z) * S(abs(m), x, y)
    else
        return N(l, m) * P(l, m, z) * C(m, x, y)
    end
end
export Y

SHFunctions(max_l, x::Node, y::Node, z::Node) = SHFunctions(Vector{Node}(undef, 0), max_l, x, y, z)
SHFunctions(max_l, x::Symbolics.Num, y::Symbolics.Num, z::Symbolics.Num) = SHFunctions(Vector{Symbolics.Num}(undef, 0), max_l, x, y, z)

function SHFunctions(shfunc, max_l, x, y, z)
    for l in 0:max_l-1
        for m in -l:l
            push!(shfunc, Y(l, m, x, y, z))
        end
    end

    return shfunc
end
export SHFunctions

function spherical_harmonics(::JuliaSymbolics, model_size)
    Symbolics.@variables x y z
    return SHFunctions(model_size, x, y, z), [x, y, z]
end

function spherical_harmonics(::FastSymbolic, model_size, x, y, z)
    graph = DerivativeGraph(SHFunctions(model_size, x, y, z))
    return graph
end

function spherical_harmonics(package::FastSymbolic, model_size)
    FD.@variables x, y, z
    return spherical_harmonics(package, model_size, x, y, z)
end
export spherical_harmonics</code></pre><p>As was the case for Chebyshev polynomials the number of paths from the roots to the variables is much greater than the number of nodes in the graph. Once again the y axis is logarithmic.</p><p><img src="../Illustrations/figure_spherical_harmonics_Symbolic_simplify_false.svg" alt="Symbolic processing, simplify=false"/> <img src="../Illustrations/figure_spherical_harmonics_MakeFunction_simplify_false.svg" alt="MakeFunction, simplify=false"/> <img src="../Illustrations/figure_spherical_harmonics_Exe_simplify_false.svg" alt="Exe, simplify=false"/></p><p>The <strong>Exe</strong> benchmark took many hours to run and was stopped at model size 24 instead of 25 as for the <strong>Symbolic</strong> and <strong>MakeFunction</strong> benchmarks.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../benchmarks/">« Benchmarks</a><a class="docs-footer-nextpage" href="../futurework/">Future work »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 1 April 2025 23:48">Tuesday 1 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
