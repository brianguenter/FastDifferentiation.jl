<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Benchmarks · FastDifferentiation.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FastDifferentiation.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../limitations/">Limitations</a></li><li><a class="tocitem" href="../howitworks/">How it works</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Benchmarks</a></li><li><a class="tocitem" href="../symbolicprocessing/">Symbolic processing</a></li><li><a class="tocitem" href="../futurework/">Future work</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Benchmarks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Benchmarks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/brianguenter/FastDifferentiation.jl/blob/main/docs/src/benchmarks.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h1><p>See <a href="https://github.com/brianguenter/Benchmarks">Benchmarks.jl</a> for the benchmark code used to generate these results.</p><p>The benchmarks test the speed of gradients, Jacobians, Hessians, and the ability to exploit sparsity in the derivative. The last problem, <code>ODE</code>, also compares the AD algorithms to a hand optimized Jacobian. There are not many benchmarks so take these results with a grain of salt; they may be useful for order of magnitude comparisons but not much more. Also, two of these packages, FastDifferentiation and Enzyme, are under active development. These benchmarks could change materially in the near future.</p><p>I am not an expert in any of these packages except for <strong>FD</strong>. For some of the benchmarks I have not yet figured out how to correctly and efficiently compute all the derivatives. I am indebted to Yingbo Ma and Billy Moses for their help debugging and improving the benchmark code for ForwardDiff and Enzyme, respectively. </p><p>Several of the AD algorithms have unexpectedly slow timings; the Enzyme Rosenbrock Hessian timings are notable in this respect since for the other benchmarks Enzyme has excellent performance. Perhaps these codes can be rewritten to be more efficient. If you are expert in any of these packages please submit a PR to fix, improve, or correct a benchmark.</p><p>When determining which AD algorithm to use keep in mind the limitations of <strong>FD</strong>: operation count and conditionals. The total operation count of your expression should be less than 10⁵. You may get reasonable performance for expressions as large as 10⁶ operations but expect very long compile times. FD does not support conditionals which involve the differentiation variables (yet). The other algorithms do not have these limitations.</p><p>To generate the markdown for the results in this section execute the function <code>write_markdown()</code> in the file <code>Benchmarks.jl</code> at the <a href="https://github.com/brianguenter/Benchmarks">Benchmarks.jl</a> repo.</p><p>These timings are just for evaluating the derivative function. They do not include preprocessing time required to generate and compile the function nor any time needed to generate auxiliary data structures that make the evaluation more efficient.</p><p>The times in each row are normalized to the shortest time in that row. The fastest algorithm will have a relative time of 1.0 and all other algorithms will have a time ≥ 1.0. Smaller numbers are better.</p><p>All benchmarks run on this system:</p><pre><code class="language-julia hljs">Julia Version 1.9.2
Commit e4ee485e90 (2023-07-05 09:39 UTC)
Platform Info:
  OS: Windows (x86_64-w64-mingw32)
  CPU: 32 × AMD Ryzen 9 7950X 16-Core Processor            
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-14.0.6 (ORCJIT, znver3)
  Threads: 1 on 32 virtual cores
Environment:
  JULIA_EDITOR = code.cmd</code></pre><table><tr><th style="text-align: right">Function</th><th style="text-align: right">FD sparse</th><th style="text-align: right">FD dense</th><th style="text-align: right">ForwardDiff</th><th style="text-align: right">ReverseDiff</th><th style="text-align: right">Enzyme</th><th style="text-align: right">Zygote</th></tr><tr><td style="text-align: right">Rosenbrock Hessian</td><td style="text-align: right"><strong>1.00</strong></td><td style="text-align: right">8.31</td><td style="text-align: right">33455.33</td><td style="text-align: right">99042.70</td><td style="text-align: right">194.5</td><td style="text-align: right">85003.60</td></tr><tr><td style="text-align: right">Rosenbrock gradient</td><td style="text-align: right"><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></td><td style="text-align: right">1.29</td><td style="text-align: right">674.82</td><td style="text-align: right">299.67</td><td style="text-align: right"><strong>1.00</strong></td><td style="text-align: right">4208.30</td></tr><tr><td style="text-align: right">Simple matrix Jacobian</td><td style="text-align: right"><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></td><td style="text-align: right"><strong>1.00</strong></td><td style="text-align: right">34.09</td><td style="text-align: right">51.25</td><td style="text-align: right"><sup class="footnote-reference"><a id="citeref-50" href="#footnote-50">[50]</a></sup></td><td style="text-align: right">125.26</td></tr><tr><td style="text-align: right">Spherical harmonics Jacobian</td><td style="text-align: right"><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></td><td style="text-align: right"><strong>1.00</strong></td><td style="text-align: right">29.25</td><td style="text-align: right"><sup class="footnote-reference"><a id="citeref-40" href="#footnote-40">[40]</a></sup></td><td style="text-align: right"><sup class="footnote-reference"><a id="citeref-51" href="#footnote-51">[51]</a></sup></td><td style="text-align: right"><sup class="footnote-reference"><a id="citeref-6" href="#footnote-6">[6]</a></sup></td></tr></table><h3 id="Comparison-to-hand-optimized-Jacobian."><a class="docs-heading-anchor" href="#Comparison-to-hand-optimized-Jacobian.">Comparison to hand optimized Jacobian.</a><a id="Comparison-to-hand-optimized-Jacobian.-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-to-hand-optimized-Jacobian." title="Permalink"></a></h3><p>This compares AD algorithms to a hand optimized Jacobian (in file ODE.jl). As before timings are relative to the fastest time. Enzyme (array) is written to accept a vector input and return a matrix output to be compatible with the calling convention for the ODE function. This is very slow because Enzyme does not yet do full optimizations on these input/output types. Enzyme (tuple) is written to accept a tuple input and returns tuple(tuples). This is much faster but not compatible with the calling convetions of the ODE function. This version uses features not avaialable in the registered version of Enzyme (as of 7-9-2023). You will need to <code>] add Enzyme#main</code> instead of using the registered version.</p><table><tr><th style="text-align: right">FD sparse</th><th style="text-align: right">FD Dense</th><th style="text-align: right">ForwardDiff</th><th style="text-align: right">ReverseDiff</th><th style="text-align: right">Enzyme (array)</th><th style="text-align: right">Enzyme (tuple)</th><th style="text-align: right">Zygote</th><th style="text-align: right">Hand optimized</th></tr><tr><td style="text-align: right"><strong>1.00</strong></td><td style="text-align: right">1.83</td><td style="text-align: right">32.72</td><td style="text-align: right"><sup class="footnote-reference"><a id="citeref-41" href="#footnote-41">[41]</a></sup></td><td style="text-align: right">281.05</td><td style="text-align: right">4.30</td><td style="text-align: right">554767.55</td><td style="text-align: right">2.50</td></tr></table><p>It is worth nothing that both FD sparse and FD dense are faster than the hand optimized Jacobian. <sup class="footnote-reference"><a id="citeref-41" href="#footnote-41">[41]</a></sup>: ODE not implemented for ReverseDiff</p><h3 id="Rate-of-growth-of-Jacobian"><a class="docs-heading-anchor" href="#Rate-of-growth-of-Jacobian">Rate of growth of Jacobian</a><a id="Rate-of-growth-of-Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Rate-of-growth-of-Jacobian" title="Permalink"></a></h3><p>It is also intersting to note the ratio of the number of operations of the <strong>FD</strong> Jacobian of a function to the number of operations in the original function. </p><p>Problem sizes in approximately the ratio 1 \:10 \: 100 \: 1000 were computed for several of the benchmarks.</p><p>The ratio (jacobian operations)/(original function operations) stays close to a constant over 2 orders of magnitude of problem size for Rosenbrock and Spherical harmonics. For the simple matrix ops Jacobian the ratio goes from 2.6 to 6.5 over 3 orders of magnitude of problem size. The ratio is growing far more slowly than the domain and codomain dimensions of the problem: the smallest instance is an R⁸-&gt;R⁴ function and the largest is R⁸⁰⁰-&gt;R⁴⁰⁰ an increase in both domain and codomain dimensions of 100x.</p><table><tr><th style="text-align: right">Relative problem size</th><th style="text-align: right">Rosenbrock Jacobian</th><th style="text-align: right">Spherical harmonics Jacobian</th><th style="text-align: right">Simple matrix ops Jacobian</th></tr><tr><td style="text-align: right">1x</td><td style="text-align: right">1.13</td><td style="text-align: right">2.2</td><td style="text-align: right">2.6</td></tr><tr><td style="text-align: right">10x</td><td style="text-align: right">1.13</td><td style="text-align: right">2.34</td><td style="text-align: right">3.5</td></tr><tr><td style="text-align: right">100x</td><td style="text-align: right">1.13</td><td style="text-align: right">2.4</td><td style="text-align: right">3.8</td></tr><tr><td style="text-align: right">1000x</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">6.5</td></tr></table><p>This is a very small sample of functions but it will be interesting to see if this slow growth of the Jacobian with increasing domain and codomain dimensions generalizes to all functions or only applies to functions with special graph structure.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><strong>FD</strong> sparse was slower than <strong>FD</strong> dense so results are only shown for dense.</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><strong>FD</strong> sparse was slower than <strong>FD</strong> dense so results are only shown for dense.</li><li class="footnote" id="footnote-50"><a class="tag is-link" href="#citeref-50">50</a>Enzyme prints &quot;Warning: using fallback BLAS replacements, performance may be degraded&quot;, followed by stack overflow error or endless loop.</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><strong>FD</strong> sparse was slower than <strong>FD</strong> dense so results are only shown for dense.</li><li class="footnote" id="footnote-40"><a class="tag is-link" href="#citeref-40">40</a>ReverseDiff failed on Spherical harmonics.</li><li class="footnote" id="footnote-51"><a class="tag is-link" href="#citeref-51">51</a>Enzyme crashes Julia REPL for SHFunctions benchmark.</li><li class="footnote" id="footnote-6"><a class="tag is-link" href="#citeref-6">6</a>Zygote doesn&#39;t work with Memoize</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../symbolicprocessing/">Symbolic processing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 8 August 2023 17:38">Tuesday 8 August 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
